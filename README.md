# Cache-Consistency-Component

架构：JDK21

背景：
系统为了提高整体的性能，一般都会对一些经常使用但不经常变动的数据进行缓存。随着系统越来越大，缓存和数据之间的关联性缺少维护：我更改了某张表的数据，但是不知道这些数据被哪些缓存依赖，就可能造成缓存漏删，进而导致较长时间的缓存不一致。为了解决这个问题，需要对这些缓存和数据的依赖关系进行维护。

原理：
1. 通过 Redis 中的 ZSET 维护缓存和数据表的依赖关系，ZSET 中的 key 为具体的表名，value 为具体的业务名称，SCORE 为当前业务的新鲜度（新鲜度越高的，在清除缓存时优先）
2. 当数据表更新的时候，就能知道当前数据表被哪些业务依赖了。
3. 为每个表都维护一个版本号，比如 ZSET 中的 Key 就为"表名:version"。当数据表更新的时候，将版本号+1，然后将旧的 Key 中的 Value 列表（具体的业务）进行批量删除，优先删除新鲜度要求高的业务。此时如果有新的数据需要被缓存，就会先读取对应表的最新版本号，然后往 ZSET 中添加新的业务依赖关系。


步骤：
1. 假设菜单业务 Menu 依赖表t_user和表t_menu，权限业务 Auth 依赖表 t_user、t_menu 和 t_contr
2. 当 Menu 业务发现 Redis 中没有缓存的时候，会从数据库查询数据在内存根据业务情况进行组装，然后将处理后的结果放到缓存中，同时判断 t_user 和 t_menu 对应的最新版本号，假设分别为 1 和 2，那么就会执行 ZADD t_user:1 Menu 和 ZADD t_menu:2 Menu。
3. 当 Auth 业务发现 Redis 中没有缓存的时候，会从数据库查询数据在内存根据业务情况进行组装，然后将处理后的结果放到缓存中，同时判断 t_user、t_menu 和 t_contr 对应的最新版本号，假设分别为 1、2 和 3，那么就会执行 ZADD t_user:1 Auth、ZADD t_menu:2 Auth 和 ZADD t_contr:3 Auth。
4. 当 t_user 表更新的时候，会先将版本号+1，此时版本为 2，然后执行 ZMEMBERS t_user:1，获取到旧版本维护的所有业务缓存依赖关系，并且在后台异步删除这些业务缓存，新鲜度要求高的业务会优先删除。
5. 当 Menu 业务再次被触发的时候，由于之前的缓存已经被清除，就会从数据库查询数据在内存根据业务情况进行组装，然后将处理后的结果放到缓存中，同时判断 t_user 和 t_menu 对应的最新版本号，此时为 2 和 2，那么就会执行 ZADD t_user:2 Menu 和 ZADD t_menu:2 Menu。